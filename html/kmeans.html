<!doctype html>
<html>
   
  <head>
    <script src="jquery.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script type="text/javascript" src="http://cdn.robotwebtools.org/EventEmitter2/current/eventemitter2.js"></script>
    <script type="text/javascript" src="http://cdn.robotwebtools.org/roslibjs/current/roslib.js"></script>
    <link rel="stylesheet" href="victoria.css">
    <script type="text/javascript">
      function DumpObjectIndented(obj, indent)
      {
        var result = "";
        if (indent == null) indent = "";

        for (var property in obj)
        {
          var value = obj[property];
          if (typeof value == 'string')
            value = "'" + value + "'";
          else if (typeof value == 'object')
          {
            if (value instanceof Array)
            {
              // Just let JS convert the Array to a string!
              value = "[ " + value + " ]";
            }
            else
            {
              // Recursive dump
              // (replace "  " by "\t" or something else if you prefer)
              var od = DumpObjectIndented(value, indent + "  ");
              // If you like { on the same line as the key
              //value = "{\n" + od + "\n" + indent + "}";
              // If you prefer { and } to be aligned
              value = "\n" + indent + "{\n" + od + "\n" + indent + "}";
            }
          }
          result += indent + "'" + property + "' : " + value + ",\n";
        }
        return result.replace(/,\n$/, "");
      }

      function showHideHistogram(checkBoxElement) {
        var histChartId = checkBoxElement.attributes['hist'].value;
        console.log("checked, id: " + checkBoxElement.id + ', hist id: ' + histChartId);
        var histogramChart = document.getElementById(histChartId);
        console.log('histogramChart: ' + histogramChart);
        if (checkBoxElement.checked) histogramChart.style.display = 'block';
        else histogramChart.style.display = 'none';
      }

      function getPlotDivName(cluster) {
        return 'cl' + cluster + 'hist';
      }

      function createCheckboxText(cluster) {
        var checkBoxId = 'cb' + getPlotDivName(cluster);
        return '<input type="checkbox" hist="' +
                getPlotDivName(cluster) + '" id="' + checkBoxId + '"  onchange="showHideHistogram(this)"/>' +
                '<label for="' + checkBoxId + '">Histograms</label>'
      }

      var CHART_HEIGHT = 80;

    	function main() {
        document.getElementById('KmeansAnnotatedImage').style.display = 'none';
        ros = new ROSLIB.Ros({
          url : 'ws:/xmyx.com:9090'
        });

        var kmeansActionClient = new ROSLIB.ActionClient({
          ros : ros,
          serverName : '/compute_kmeans',
          actionName : 'victoria_perception/KmeansAction'
        });

        console.log('Sending goal');
        var goal = new ROSLIB.Goal({
          actionClient : kmeansActionClient,
          goalMessage : {
            image_topic_name : '/usb_cam/image_raw',
            number_clusters : 16,
            resize_width : 320
          }
        });

        var feedbackChannel0 = [];
        var feedbackChannel1 = [];
        var feedbackChannel2 = [];

        goal.on('feedback', function(feedback) {
          console.log('Feedback: ' + feedback.step);
          var fb = JSON.parse(feedback.step);
          if (fb.channel == 0) {
            feedbackChannel0[fb.cluster] = fb;
         } else if (fb.channel == 1) {
            feedbackChannel1[fb.cluster] = fb;
          } else if (fb.channel == 2) {
            feedbackChannel2[fb.cluster] = fb;
          }
        });

        goal.on('result', function(result) {
          console.log('Final result_msg: ' + result.result_msg);
          console.log('Final kmeans_result: ' + result.kmeans_result);
          var feedbackRows = '<tr><th>Merge</th><th>Show</th><th>Cluster</th><th>Statistics</th></tr>';
          for (cluster = 0; cluster < feedbackChannel0.length; cluster++) {
            var fb0 = feedbackChannel0[cluster];
            var fb1 = feedbackChannel1[cluster];
            var fb2 = feedbackChannel2[cluster];
            var cellText = 
              '<b style="color: rgb(31, 119, 180)">hue:</b> [' + fb0.min + '..' + fb0.max + '] ' +
              ', <b style="color: rgb(255, 127, 14)">saturation:</b> [' + fb1.min + '..' + fb1.max + '] ' +
              ', <b style="color: rgb(44, 168, 44)">value:</b> [' + fb2.min + '..' + fb2.max + '] ' +
              ', <b>points: </b>' + fb0.selected_point_count;
            feedbackRows += '<tr><td>X</td>' +
                                '<td>' + createCheckboxText(cluster) + '</td>' +
                                '<td>' + cluster + '</td>' +
                                '<td class="histogram_data_cell">' + cellText + '</td>' +
                            '</tr>' +
                            '<tr><td></td><td></td><td></td><td><div id="' + getPlotDivName(cluster) + '" style="height: ' + CHART_HEIGHT + '; display: none"></td></tr>';
          }

          var feedbackTable = document.getElementById("FeedbackTable");
          feedbackTable.innerHTML = feedbackRows;

          for (cluster = 0; cluster < feedbackChannel0.length; cluster++) {
            var fb0 = feedbackChannel0[cluster];
            var fb1 = feedbackChannel1[cluster];
            var fb2 = feedbackChannel2[cluster];
            var hueY = [];
            var satY = [];
            var valY = [];
            var fb0Max = 0;
            var fb1Max = 0;
            var fb2Max = 0;

            for (i = 0; i < fb0.histogram.length; i++) {
              hueY[i] = fb0.histogram[i];
              satY[i] = fb1.histogram[i];
              valY[i] = fb2.histogram[i];
              if (fb0.histogram[i] > fb0Max) fb0Max = fb0.histogram[i];
              if (fb1.histogram[i] > fb1Max) fb1Max = fb1.histogram[i];
              if (fb2.histogram[i] > fb2Max) fb2Max = fb2.histogram[i];
            }

            var huePlot = {
              dx: 1,
              line: { color: 'rgb(31, 119, 180)' },
              name: 'hue',
              type: 'scatter',
              y: hueY,
            };

            var satPlot = {
              dx: 1,
              line: { color: 'rgb(255, 127, 14)' },
              name: 'saturation',
              type: 'scatter',
              y: satY,
            };

            var valPlot = {
              dx: 1,
              line: { color: 'rgb(44, 168, 44)' },
              name: 'value',
              type: 'scatter',
              y: valY,
            };

            var layout = {
              autosize: false,
              height: 150,
              margin: {
                b: 30,
                l: 40,
                pad: 4,
                r: 10,
                t: 10
              },
              shapes: [
                {
                  type: 'line', 
                  x0: fb0.min, y0: 0, x1: fb0.min, y1: fb0Max, 
                  line: {color: 'rgb(31, 119, 180)', dash: 'dashdot'}

                },
                {
                  type: 'line', 
                  x0: fb0.max, y0: 0, x1: fb0.max, y1: fb0Max, 
                  line: {color: 'rgb(31, 119, 180)', dash: 'dashdot'}

                },
                {
                  type: 'line', 
                  x0: fb1.min, y0: 0, x1: fb1.min, y1: fb1Max, 
                  line: {color: 'rgb(255, 127, 14)', dash: 'dashdot'}

                },
                {
                  type: 'line', 
                  x0: fb1.max, y0: 0, x1: fb1.max, y1: fb1Max, 
                  line: {color: 'rgb(255, 127, 14)', dash: 'dashdot'}

                },
                {
                  type: 'line', 
                  x0: fb2.min, y0: 0, x1: fb2.min, y1: fb2Max, 
                  line: {color: 'rgb(44, 168, 44)', dash: 'dashdot'}

                },
                {
                  type: 'line', 
                  x0: fb2.max, y0: 0, x1: fb2.max, y1: fb2Max, 
                  line: {color: 'rgb(44, 168, 44)', dash: 'dashdot'}

                }
              ],
              width: 800,
              xaxis: {
                dtick: 10
              }
            };

            Plotly.newPlot(getPlotDivName(cluster), [huePlot, satPlot, valPlot], layout);
          }

          document.getElementById('KmeansAnnotatedImage').style.display = 'block';
          document.getElementById('KmeansAnnotatedImage').src="http://xmyx.com:8080/snapshot?topic=/kmeans/annotated_image"
        });

        ros.on('connection', function() {
          console.log('Connected to websocket server.');
        });

        ros.on('error', function(error) {
          console.log('Error connecting to websocket server: ', error);
        });

        ros.on('close', function() {
          console.log('Connection to websocket server closed.');
        });

        goal.send();      
    	}

      </script>
   </head>   
   <body onload="main()">
      <img id="KmeansAnnotatedImage" style=display:none" />
      <div>
        <table id="FeedbackTable">
        </table>
      </div>
      
   </body>
</html>
